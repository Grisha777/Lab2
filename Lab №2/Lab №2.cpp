//Кафедра "Информационная безопасность" (ИУ8)
//Зимин Г.С.
//ИУ8-22
//Лабораторная работа №2
//Задача №1

#include <iostream>
#include <fstream>
#include <vector>
using namespace std;
class Vector // Класс- вектор
{
	double *p; // Указатель на массив
	int n; // Размерность массива
public:
	Vector(double *p, int n) // Коструктор на вход в массив
	{
		this->n = n;
		this->p = new double[n]; // Выделяем память
		for (int z = 0; z < n; z++) 
			this->p[z] = p[z]; 
	}


	Vector(const Vector &vector)
	{ // Конструктор копирования
		n = vector.n;
		p = new double[n];
		for (int z = 0; z < n; z++)
			p[z] = vector.p[z];
	}


    // Конструктор перемещения
	Vector(Vector&& vector1) // Параметр - правосторонняя ссылкa
		:p(vector1.p), n(vector1.n)
	{
		vector1.p = nullptr;
		vector1.n = 0;
	}

	void print() const // Печать вектора с заменой на перегрузку
	{
		for (int i = 0; i < n; i++)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}

	Vector() 
	{ 
		p = nullptr; n = 0; // Конструктор без параметров, задает "пустой" объект
	}
		double &operator[](int index) // Оператор - функция (перегрузка операции обращения к элементу)
	{
		return p[index];
	}


	Vector &operator =(const Vector &vector2) // Оператор- функция копирования объекта
	{
		n = vector2.n;
		if (p!= nullptr) 
			delete[] p; // Освобождаем память старого вектора
		p = new double[n]; // Выделяем память для нового вектора
		for (int z = 0; z < n; z++)
			p[z] = vector2.p[z];
		return *this; // Возвращаем ссылку на текущий объект
	}


	~Vector() // Деструктор
	{
		if (p != nullptr) 
			delete[] p; // Освобождаем память
	}
	friend class Vector &operator *(double x, Vector &vector2); // Дружественная функция,определенная вне класса
};


// Умножение числа на вектор 
Vector &operator *(double x, Vector & vector2) // Оператор- функция вне класса
{
	double *p = new double[vector2.n]; // Создаем новый массив
	for (int z = 0; z < vector2.n; z++)
		p[z] = x * vector2.p[z]; // Заполняем массив
	Vector *pV = new Vector(p, vector2.n); // Создаем новый объект на основе массива
	delete[] p;
	return *pV; // Возвращаем ссылку на объект
}


int main()
{
	double m1[] = {5,7,11,13,17,19,23};
	Vector V1(m1, 7); // Создаем объект
	V1.print(); // Печать объекта
	Vector V2; // Новый объект 
	V2 = 10000 * V1; // Перегруженная операция *
	V2.print(); // Печать объекта

	// Работа с файлом в текстовом режиме
	ofstream foutt("Vector.txt"); // открываем файл для записи в текстовом режиме
	foutt << m1 << endl; // Записываем n в текстовом режиме, далее переход на новую строкe
	foutt<< "V1= " << endl<< "V2= " <<ends; // Каждая строка с новой строчки	
	foutt.close(); // закрываем файл

	system("pause");
	return 0;
}


// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.

//Кафедра "Информационная безопасность" (ИУ8)
//Зимин Г.С.
//ИУ8-22
//Лабораторная работа №2
//Задача №1

#include <iostream>
using namespace std;
class Vector // Класс- вектор
{
	double *p; // Указатель на массив
	int n; // Размерность массива
public:
	Vector(double *p, int n) // Коструктор на вход в массив
	{
		this->n = n;
		this->p = new double[n]; // Выделяем память
		for (int z = 0; z < n; z++) 
			this->p[z] = p[z]; 
	}


	Vector(const Vector &вектор)
	{ // Конструктор копирования
		n = вектор.n;
		p = new double[n];
		for (int z = 0; z < n; z++)
			p[z] = вектор.p[z];
	}


    // Конструктор перемещения
	Vector(Vector&& вектор1) // Параметр - правосторонняя ссылкa
		:p(вектор1.p), n(вектор1.n)
	{
		вектор1.p = nullptr;
		вектор1.n = 0;
	}


	void print() const 
	{
		for (int z = 0; z < n; z++)
			cout << p[z] << "  "<< endl;
	}


	Vector() { p = nullptr; n = 0; } // Конструктор без параметров, задает "пустой" объект
		double& operator[](int index) // Оператор- функция (перегрузка операции обращения к элементу)
	{
		return p[index];
	}


	Vector &operator =(const Vector &вектор2) // Оператор- функция копирования объекта
	{
		n = вектор2.n;
		if (p!= nullptr) delete[] p; // Освобождаем память старого вектора
		p = new double[n]; // Выделяем память для нового вектора
		for (int z = 0; z < n; z++)
			p[z] = вектор2.p[z];
		return *this; // Возвращаем ссылку на текущий объект
	}


	~Vector() // Деструктор
	{
		if (p != nullptr) 
			delete[] p; // Освобождаем память
	}
	friend class Vector &operator *(double x, Vector &вектор2); // Дружественная функция,определенная вне класса
};


// Умножение числа на вектор (первый операнд не объект класса,
// функция обязательно определяется вне класса)
Vector &operator *(double x, Vector &вектор2) // Оператор- функция вне класса
{
	double *p = new double[вектор2.n]; // Создаем новый массив
	for (int z = 0; z < вектор2.n; z++) 
		p[z] = x * вектор2.p[z]; // Заполняем массив
	Vector *pV = new Vector(p, вектор2.n); // Создаем новый объект на основе массива
	delete[] p;
	return *pV; // Возвращаем ссылку на объект
}


int main()
{
	double m1[] = {5,7,11,13,17,19,23};
	Vector V1(m1, 7); // Создаем объект
	V1.print(); // Печать объекта
	Vector V2; // Новый объект (вначале "пустой")
	V2 = 1000000000000000000 * V1; // Пример выполнение перегруженной операции *
	V2.print(); // Печать полученного объекта
	return 0;
}


// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
